from collections import deque

def bfs(p):
    start = []
    
    for i in range(5): # 시작점이 되는 P 좌표 구하기
        for j in range(5):
            if p[i][j] == 'P':
                start.append([i, j])
    
    for s in start:
        queue = deque([s])  # 큐에 초기값
        visited = [[0]*5 for i in range(5)]   # 방문 처리 리스트
        distance = [[0]*5 for i in range(5)]  # 경로 길이 리스트
        visited[s[0]][s[1]] = 1
        
        while queue:
            y, x = queue.popleft()
        
            dx = [-1, 1, 0, 0]  # 좌우
            dy = [0, 0, -1, 1]  # 상하

            for i in range(4):
                nx = x + dx[i]
                ny = y + dy[i]

                if 0<=nx<5 and 0<=ny<5 and visited[ny][nx] == 0:
                    
                    if p[ny][nx] == 'O':
                        queue.append([ny, nx])
                        visited[ny][nx] = 1
                        distance[ny][nx] = distance[y][x] + 1
                    
                    if p[ny][nx] == 'P' and distance[y][x] <= 1:
                        return 0
    return 1


def solution(places):
    answer = []
    
    for i in places:
        answer.append(bfs(i))
    
    return answer

# from collections import deque

# def BFS(start_x, start_y, place) :
#     dx = [-1, 0, 1, 0]
#     dy = [0, 1, 0, -1]
    
#     dq = deque()
#     visited_list = [[False] * 5 for _ in range(5)]      #방문 처리 리스트
#     distance_list = [[False] * 5 for _ in range(5)]     #경로 길이 리스트
    
#     dq.append((start_x, start_y))                       #큐에 초기값
#     visited_list[start_x][start_y] = True               #시작값 방문처리
    
#     while dq : 
#         now_index = dq.popleft()
        
#         for d in range(4) :
#             next_x = now_index[0] + dx[d]
#             next_y = now_index[1] + dy[d]
            
#             if 0 <= next_x < 5 and 0 <= next_y < 5 and visited_list[next_x][next_y] is False :
                
#                 #O : 빈 테이블인 경우
#                 if place[next_x][next_y] == "O" :
#                     dq.append((next_x, next_y))
#                     visited_list[next_x][next_y] = True
#                     distance_list[next_x][next_y] += distance_list[start_x][start_y]
                
#                 #파티션으로 막혀있는 경우 또는 거리가 1 이하로 앉은 경우
#                 if place[next_x][next_y] == "P" and distance_list[start_x][start_y] <= 1 :
#                     return 0
#     return 1
            
    

# def solution(places):
#     answer = []
    
#     for place in places :
#         #print(place)
#         flag = False
#         p_count = 0
#         for i in range(len(place)) :
#             for j in range(len(place)) :
#                 if place[i][j] == "P" :
#                     p_count += 1
#                     temp = BFS(i, j, place)
#                     #print(temp)
#                     if temp == 1 :
#                         flag = True
#         if p_count == 0 or flag == True : 
#             answer.append(1)
#         else :
#             answer.append(0)

#     return answer